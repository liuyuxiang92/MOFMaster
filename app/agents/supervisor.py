import logging
import json
import re
from langchain_core.messages import SystemMessage

from app.state import AgentState
from app.schema import SupervisorReview
from app.utils.llm import get_supervisor_llm

# Setup logger
logger = logging.getLogger(__name__)


SUPERVISOR_SYSTEM_PROMPT = """You are a Principal Investigator (PI) reviewing a computational chemistry workflow plan.

Your job is to ensure the plan is:
1. SCIENTIFICALLY SOUND - Operations are in the correct order
2. FEASIBLE - Only uses available tools
3. SAFE - Won't waste compute or cause errors

SCIENTIFIC RULES:
- Structure acquisition (search_mof_db) must happen before operations on structures
- Optimization (optimize_structure_ase) should typically happen before energy calculations
- Energy calculations (calculate_energy_force) should use optimized structures when possible

AVAILABLE TOOLS:
- search_mof_db: Search for MOF structures
- optimize_structure_ase: Optimize geometry
- calculate_energy_force: Calculate energy and forces

{revision_context}

REVIEW THE PLAN:
{plan}

IMPORTANT: You must respond with valid JSON only. The response will be parsed as JSON.
Provide your review as a JSON object with:
- "approved": true or false (boolean)
- "feedback": "Detailed explanation" (string)

If approved, explain why the plan is good.
If rejected, explain what's wrong and how to fix it.
{revision_instructions}
"""


async def supervisor_node(state: AgentState) -> AgentState:
    """
    Supervisor Agent - Reviews the plan for scientific soundness.

    Uses an LLM to validate the execution plan generated by the Analyzer.
    Checks order of operations, feasibility, and safety.
    """

    # Get the latest plan from state - ensure we're reading the current state
    plan = state.get("plan", [])
    
    # Debug: Print what plan the supervisor is seeing
    logger.debug(f"üîç Supervisor: Received plan from state: {plan}")
    logger.debug(f"üîç Supervisor: Plan type: {type(plan)}, Plan length: {len(plan) if plan else 0}")
    logger.debug(f"üîç Supervisor: Full state keys: {list(state.keys())}")

    if not plan:
        # No plan to review, skip
        logger.warning("‚ö†Ô∏è  Supervisor: No plan found in state!")
        state["is_plan_approved"] = False
        state["review_feedback"] = "No plan provided"
        return state

    # Check if this is a revised plan
    rejection_count = state.get("_rejection_count", 0)
    previous_plan = state.get("_previous_plan", [])
    previous_feedback = state.get("review_feedback", "")
    
    logger.debug(f"üîç Supervisor: rejection_count={rejection_count}")
    logger.debug(f"üîç Supervisor: previous_plan={previous_plan} (length={len(previous_plan) if previous_plan else 0})")
    logger.debug(f"üîç Supervisor: current_plan={plan} (length={len(plan)})")
    logger.debug(f"üîç Supervisor: previous_feedback={previous_feedback[:100] if previous_feedback else 'None'}...")
    
    # Verify we have the latest plan - compare with previous if available
    if previous_plan and plan == previous_plan:
        logger.warning(f"‚ö†Ô∏è  WARNING: Current plan is identical to previous plan! This might indicate a state update issue.")
    elif previous_plan:
        logger.info(f"‚úÖ Plan has changed from previous version")
    
    # Build revision context if this is a revision
    if rejection_count > 0 and previous_plan:
        revision_context = f"""
‚ö†Ô∏è  REVISED PLAN - This is revision #{rejection_count + 1}

PREVIOUS PLAN (that was rejected):
{chr(10).join(f"{i+1}. {step}" for i, step in enumerate(previous_plan))}

YOUR PREVIOUS FEEDBACK:
{previous_feedback}

CURRENT REVISED PLAN (to review):
"""
        revision_instructions = """

IMPORTANT FOR REVISIONS:
- Compare the revised plan with the previous plan and your feedback
- Check if the revisions address your previous concerns
- If the plan has improved based on your feedback, consider approving it
- If the plan still has the same issues or new problems, provide specific feedback on what still needs to be fixed
"""
    else:
        revision_context = ""
        revision_instructions = ""

    # Create review prompt
    llm = get_supervisor_llm()

    # Use structured output with JSON mode
    # Try to use response_format if available (OpenAI JSON mode)
    try:
        # For OpenAI-compatible APIs, try to enable JSON mode
        if hasattr(llm, 'bind'):
            # Try binding response_format for JSON mode
            structured_llm = llm.bind(response_format={"type": "json_object"}).with_structured_output(SupervisorReview)
        else:
            structured_llm = llm.with_structured_output(SupervisorReview)
    except Exception:
        # Fallback to standard structured output
        structured_llm = llm.with_structured_output(SupervisorReview)

    system_message = SystemMessage(
        content=SUPERVISOR_SYSTEM_PROMPT.format(
            revision_context=revision_context,
            plan="\n".join(f"{i+1}. {step}" for i, step in enumerate(plan)),
            revision_instructions=revision_instructions
        )
    )

    # Get review
    try:
        review = await structured_llm.ainvoke([system_message])
        logger.info(f"‚úÖ Supervisor review: approved={review.approved}, feedback={review.feedback[:100]}...")
    except Exception as e:
        # If structured output fails, fall back to manual parsing
        logger.warning(f"‚ö†Ô∏è  Structured output failed, attempting fallback: {e}")
        try:
            response = await llm.ainvoke([system_message])
            content = response.content if hasattr(response, 'content') else str(response)
            logger.debug(f"üìù Raw supervisor response: {content[:300]}...")
            
            # Try to parse JSON from response
            import json
            import re
            # Look for JSON object with approved field
            json_match = re.search(r'\{[^{}]*"approved"[^{}]*\}', content, re.DOTALL)
            if not json_match:
                # Try to find any JSON object
                json_match = re.search(r'\{.*?"approved".*?\}', content, re.DOTALL)
            
            if json_match:
                try:
                    parsed = json.loads(json_match.group(0))
                    review = SupervisorReview(
                        approved=parsed.get("approved", False),
                        feedback=parsed.get("feedback", content[:500])
                    )
                    logger.info(f"‚úÖ Parsed review from fallback: approved={review.approved}")
                except json.JSONDecodeError as je:
                    logger.error(f"‚ùå JSON decode error: {je}")
                    # Last resort: be lenient and approve if plan looks reasonable
                    review = SupervisorReview(
                        approved=len(plan) > 0,  # Approve if we have a plan
                        feedback=f"Could not parse review. Auto-approving reasonable plan. Error: {str(je)[:100]}"
                    )
            else:
                # No JSON found, be lenient - approve if plan exists and looks reasonable
                logger.warning(f"‚ö†Ô∏è  No JSON found in response. Plan length: {len(plan)}")
                review = SupervisorReview(
                    approved=len(plan) > 0,  # Approve if we have a plan
                    feedback=f"Could not parse JSON from response. Auto-approving plan. Response preview: {content[:200]}"
                )
        except Exception as fallback_error:
            logger.error(f"‚ùå Fallback parsing also failed: {fallback_error}")
            # Last resort: approve if plan exists
            review = SupervisorReview(
                approved=len(plan) > 0,
                feedback=f"Error getting supervisor review: {str(fallback_error)[:200]}. Auto-approving plan."
            )

    # Update state
    state["is_plan_approved"] = review.approved
    state["review_feedback"] = review.feedback
    
    # Track rejection count to prevent infinite loops
    if not review.approved:
        rejection_count = state.get("_rejection_count", 0)
        rejection_count += 1
        state["_rejection_count"] = rejection_count
        
        # Auto-approve after 3 rejections to prevent infinite loop
        if rejection_count >= 3:
            logger.warning(f"‚ö†Ô∏è  Auto-approving plan after {rejection_count} rejections to prevent infinite loop")
            state["is_plan_approved"] = True
            state["review_feedback"] = f"Auto-approved after {rejection_count} rejections. Previous feedback: {review.feedback}"
    else:
        # Reset rejection count and clear previous plan on approval
        state["_rejection_count"] = 0
        state["_previous_plan"] = []

    return state
