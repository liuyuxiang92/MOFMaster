"""
Supervisor Agent - Plan Review and Quality Control
"""

from langchain_core.messages import SystemMessage

from app.state import AgentState
from app.schema import SupervisorReview
from app.utils.llm import get_supervisor_llm


SUPERVISOR_SYSTEM_PROMPT = """You are a Principal Investigator (PI) reviewing a computational chemistry workflow plan.

Your job is to ensure the plan is:
1. SCIENTIFICALLY SOUND - Operations are in the correct order
2. FEASIBLE - Only uses available tools
3. SAFE - Won't waste compute or cause errors

SCIENTIFIC RULES:
- Structure acquisition (search_mof_db) must happen before operations on structures
- Optimization (optimize_structure_ase) should typically happen before energy calculations
- Energy calculations (calculate_energy_force) should use optimized structures when possible

AVAILABLE TOOLS:
- search_mof_db: Search for MOF structures
- optimize_structure_ase: Optimize geometry
- calculate_energy_force: Calculate energy and forces

REVIEW THE PLAN:
{plan}

IMPORTANT: You must respond with valid JSON only. The response will be parsed as JSON.
Provide your review as a JSON object with:
- "approved": true or false (boolean)
- "feedback": "Detailed explanation" (string)

If approved, explain why the plan is good.
If rejected, explain what's wrong and how to fix it.
"""


def supervisor_node(state: AgentState) -> AgentState:
    """
    Supervisor Agent - Reviews the plan for scientific soundness.

    Uses an LLM to validate the execution plan generated by the Analyzer.
    Checks order of operations, feasibility, and safety.
    """

    plan = state.get("plan", [])

    if not plan:
        # No plan to review, skip
        state["is_plan_approved"] = False
        state["review_feedback"] = "No plan provided"
        return state

    # Create review prompt
    llm = get_supervisor_llm()

    # Use structured output with JSON mode
    # Try to use response_format if available (OpenAI JSON mode)
    try:
        # For OpenAI-compatible APIs, try to enable JSON mode
        if hasattr(llm, 'bind'):
            # Try binding response_format for JSON mode
            structured_llm = llm.bind(response_format={"type": "json_object"}).with_structured_output(SupervisorReview)
        else:
            structured_llm = llm.with_structured_output(SupervisorReview)
    except Exception:
        # Fallback to standard structured output
        structured_llm = llm.with_structured_output(SupervisorReview)

    system_message = SystemMessage(
        content=SUPERVISOR_SYSTEM_PROMPT.format(
            plan="\n".join(f"{i+1}. {step}" for i, step in enumerate(plan))
        )
    )

    # Get review
    try:
        review = structured_llm.invoke([system_message])
        print(f"âœ… Supervisor review: approved={review.approved}, feedback={review.feedback[:100]}...")
    except Exception as e:
        # If structured output fails, fall back to manual parsing
        print(f"âš ï¸  Structured output failed, attempting fallback: {e}")
        try:
            response = llm.invoke([system_message])
            content = response.content if hasattr(response, 'content') else str(response)
            print(f"ðŸ“ Raw supervisor response: {content[:300]}...")
            
            # Try to parse JSON from response
            import json
            import re
            # Look for JSON object with approved field
            json_match = re.search(r'\{[^{}]*"approved"[^{}]*\}', content, re.DOTALL)
            if not json_match:
                # Try to find any JSON object
                json_match = re.search(r'\{.*?"approved".*?\}', content, re.DOTALL)
            
            if json_match:
                try:
                    parsed = json.loads(json_match.group(0))
                    review = SupervisorReview(
                        approved=parsed.get("approved", False),
                        feedback=parsed.get("feedback", content[:500])
                    )
                    print(f"âœ… Parsed review from fallback: approved={review.approved}")
                except json.JSONDecodeError as je:
                    print(f"âŒ JSON decode error: {je}")
                    # Last resort: be lenient and approve if plan looks reasonable
                    review = SupervisorReview(
                        approved=len(plan) > 0,  # Approve if we have a plan
                        feedback=f"Could not parse review. Auto-approving reasonable plan. Error: {str(je)[:100]}"
                    )
            else:
                # No JSON found, be lenient - approve if plan exists and looks reasonable
                print(f"âš ï¸  No JSON found in response. Plan length: {len(plan)}")
                review = SupervisorReview(
                    approved=len(plan) > 0,  # Approve if we have a plan
                    feedback=f"Could not parse JSON from response. Auto-approving plan. Response preview: {content[:200]}"
                )
        except Exception as fallback_error:
            print(f"âŒ Fallback parsing also failed: {fallback_error}")
            # Last resort: approve if plan exists
            review = SupervisorReview(
                approved=len(plan) > 0,
                feedback=f"Error getting supervisor review: {str(fallback_error)[:200]}. Auto-approving plan."
            )

    # Update state
    state["is_plan_approved"] = review.approved
    state["review_feedback"] = review.feedback

    return state
